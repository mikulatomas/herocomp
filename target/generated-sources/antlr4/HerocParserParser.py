# Generated from java-escape by ANTLR 4.4
from antlr4 import *
from io import StringIO
package = globals().get("__package__", None)
ischild = len(package)>0 if package is not None else False
if ischild:
    from .HerocParserListener import HerocParserListener
else:
    from HerocParserListener import HerocParserListener
def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u0430\ud6d1\u8206\uad2d\u4417\uaef1\u8d80\uaadd\3A")
        buf.write("t\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7\4\b")
        buf.write("\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16\t")
        buf.write("\16\3\2\7\2\36\n\2\f\2\16\2!\13\2\3\3\3\3\5\3%\n\3\3\4")
        buf.write("\3\4\3\4\3\4\3\5\3\5\3\5\5\5.\n\5\3\5\3\5\3\5\3\6\3\6")
        buf.write("\3\6\3\6\5\6\67\n\6\3\7\3\7\3\7\5\7<\n\7\3\7\3\7\3\7\3")
        buf.write("\b\3\b\5\bC\n\b\3\b\3\b\3\t\3\t\3\t\3\t\3\t\7\tL\n\t\f")
        buf.write("\t\16\tO\13\t\3\n\3\n\5\nS\n\n\3\13\3\13\3\f\3\f\3\r\3")
        buf.write("\r\3\r\3\r\3\r\3\r\3\r\5\r`\n\r\3\r\3\r\3\r\3\r\3\r\3")
        buf.write("\r\7\rh\n\r\f\r\16\rk\13\r\3\16\3\16\3\16\3\16\3\16\5")
        buf.write("\16r\n\16\3\16\2\4\20\30\17\2\4\6\b\n\f\16\20\22\24\26")
        buf.write("\30\32\2\4\6\2\25\25\27\27\32\32\35\35\4\2\30\30\33\33")
        buf.write("v\2\37\3\2\2\2\4$\3\2\2\2\6&\3\2\2\2\b*\3\2\2\2\n\66\3")
        buf.write("\2\2\2\f8\3\2\2\2\16@\3\2\2\2\20F\3\2\2\2\22R\3\2\2\2")
        buf.write("\24T\3\2\2\2\26V\3\2\2\2\30_\3\2\2\2\32q\3\2\2\2\34\36")
        buf.write("\5\4\3\2\35\34\3\2\2\2\36!\3\2\2\2\37\35\3\2\2\2\37 \3")
        buf.write("\2\2\2 \3\3\2\2\2!\37\3\2\2\2\"%\5\6\4\2#%\5\b\5\2$\"")
        buf.write("\3\2\2\2$#\3\2\2\2%\5\3\2\2\2&\'\7\n\2\2\'(\79\2\2()\7")
        buf.write("\67\2\2)\7\3\2\2\2*+\79\2\2+-\7\3\2\2,.\5\n\6\2-,\3\2")
        buf.write("\2\2-.\3\2\2\2./\3\2\2\2/\60\7\62\2\2\60\61\5\16\b\2\61")
        buf.write("\t\3\2\2\2\62\67\79\2\2\63\64\79\2\2\64\65\78\2\2\65\67")
        buf.write("\5\n\6\2\66\62\3\2\2\2\66\63\3\2\2\2\67\13\3\2\2\289\7")
        buf.write("9\2\29;\7\3\2\2:<\5\32\16\2;:\3\2\2\2;<\3\2\2\2<=\3\2")
        buf.write("\2\2=>\7\62\2\2>?\7\67\2\2?\r\3\2\2\2@B\7\65\2\2AC\5\20")
        buf.write("\t\2BA\3\2\2\2BC\3\2\2\2CD\3\2\2\2DE\7\66\2\2E\17\3\2")
        buf.write("\2\2FG\b\t\1\2GH\5\22\n\2HM\3\2\2\2IJ\f\3\2\2JL\5\22\n")
        buf.write("\2KI\3\2\2\2LO\3\2\2\2MK\3\2\2\2MN\3\2\2\2N\21\3\2\2\2")
        buf.write("OM\3\2\2\2PS\5\6\4\2QS\5\f\7\2RP\3\2\2\2RQ\3\2\2\2S\23")
        buf.write("\3\2\2\2TU\t\2\2\2U\25\3\2\2\2VW\t\3\2\2W\27\3\2\2\2X")
        buf.write("Y\b\r\1\2Y`\79\2\2Z`\7:\2\2[`\7;\2\2\\`\7<\2\2]`\7=\2")
        buf.write("\2^`\7>\2\2_X\3\2\2\2_Z\3\2\2\2_[\3\2\2\2_\\\3\2\2\2_")
        buf.write("]\3\2\2\2_^\3\2\2\2`i\3\2\2\2ab\f\3\2\2bc\5\24\13\2cd")
        buf.write("\5\30\r\4dh\3\2\2\2ef\f\4\2\2fh\5\26\f\2ga\3\2\2\2ge\3")
        buf.write("\2\2\2hk\3\2\2\2ig\3\2\2\2ij\3\2\2\2j\31\3\2\2\2ki\3\2")
        buf.write("\2\2lr\5\30\r\2mn\5\30\r\2no\78\2\2op\5\32\16\2pr\3\2")
        buf.write("\2\2ql\3\2\2\2qm\3\2\2\2r\33\3\2\2\2\16\37$-\66;BMR_g")
        buf.write("iq")
        return buf.getvalue()
		

class HerocParserParser ( Parser ):

    grammarFileName = "java-escape"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    EOF = Token.EOF
    T__0=1
    BREAK=2
    CONTINUE=3
    DO=4
    ELSE=5
    FOR=6
    IF=7
    LONG=8
    RETURN=9
    SIZEOF=10
    WHILE=11
    NOT=12
    NOT_EQUAL=13
    MOD=14
    MOD_ASIGN=15
    AND=16
    AND_AND=17
    AND_ASSIGN=18
    STAR=19
    STAR_ASSIGN=20
    PLUS=21
    PLUS_PLUS=22
    PLUS_ASSIGN=23
    MINUS=24
    MINUS_MINUS=25
    MINUS_ASSIGN=26
    DIV=27
    DIV_ASSIGN=28
    COLON=29
    LESS=30
    LEFT_SHIFT=31
    LEFT_SHIFT_ASSIGN=32
    LESS_EQUAL=33
    ASSIGN=34
    EQUAL=35
    GREATER=36
    GREATER_EQUAL=37
    RIGHT_SHIFT=38
    RIGHT_SHIFT_ASSIGN=39
    QUESTION=40
    CARET=41
    XOR_ASSIGN=42
    OR=43
    OR_ASSIGN=44
    OR_OR=45
    TILDE=46
    LEFT_PAREN=47
    RIGHT_PAREN=48
    LEFT_BRACKET=49
    RIGHT_BRACKET=50
    LEFT_BRACE=51
    RIGHT_BRACE=52
    SEMI=53
    COMMA=54
    IDENTIFIER=55
    CONSTANT=56
    OCTAL_CONSTANT=57
    HEX_CONSTANT=58
    CHAR=59
    STRING=60
    WHITESPACE=61
    NEWLINE=62
    COMMENT=63

    tokenNames = [ "<INVALID>", "'('", "BREAK", "'continue'", "'do'", "'else'", 
                   "'for'", "'if'", "'long'", "'return'", "'sizeof'", "'while'", 
                   "NOT", "'!='", "'%'", "'%='", "'&'", "'&&'", "'&='", 
                   "'*'", "'*='", "'+'", "'++'", "'+='", "'-'", "'--'", 
                   "'-='", "'/'", "'/='", "':'", "'<'", "'<<'", "'<<='", 
                   "'<='", "'='", "'=='", "'>'", "'>='", "'>>'", "'>>='", 
                   "'?'", "'^'", "'^='", "'|'", "'|='", "'||'", "'~'", "LEFT_PAREN", 
                   "')'", "'['", "']'", "'{'", "'}'", "';'", "','", "IDENTIFIER", 
                   "CONSTANT", "OCTAL_CONSTANT", "HEX_CONSTANT", "CHAR", 
                   "STRING", "WHITESPACE", "NEWLINE", "COMMENT" ]

    RULE_program = 0
    RULE_declaration = 1
    RULE_declarationVariable = 2
    RULE_declarationFunction = 3
    RULE_functionDeclarationArgsList = 4
    RULE_functionCall = 5
    RULE_compoundStatement = 6
    RULE_blockItemList = 7
    RULE_blockItem = 8
    RULE_binaryMathOperations = 9
    RULE_unaryMathOperations = 10
    RULE_expression = 11
    RULE_expressionList = 12

    ruleNames =  [ "program", "declaration", "declarationVariable", "declarationFunction", 
                   "functionDeclarationArgsList", "functionCall", "compoundStatement", 
                   "blockItemList", "blockItem", "binaryMathOperations", 
                   "unaryMathOperations", "expression", "expressionList" ]

    def __init__(self, input:TokenStream):
        super().__init__(input)
        self.checkVersion("4.4")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class ProgramContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def declaration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HerocParserParser.DeclarationContext)
            else:
                return self.getTypedRuleContext(HerocParserParser.DeclarationContext,i)


        def getRuleIndex(self):
            return HerocParserParser.RULE_program

        def enterRule(self, listener:ParseTreeListener):
            if isinstance( listener, HerocParserListener ):
                listener.enterProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if isinstance( listener, HerocParserListener ):
                listener.exitProgram(self)




    def program(self):

        localctx = HerocParserParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 29
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==HerocParserParser.LONG or _la==HerocParserParser.IDENTIFIER:
                self.state = 26 
                self.declaration()
                self.state = 31
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DeclarationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def declarationVariable(self):
            return self.getTypedRuleContext(HerocParserParser.DeclarationVariableContext,0)


        def declarationFunction(self):
            return self.getTypedRuleContext(HerocParserParser.DeclarationFunctionContext,0)


        def getRuleIndex(self):
            return HerocParserParser.RULE_declaration

        def enterRule(self, listener:ParseTreeListener):
            if isinstance( listener, HerocParserListener ):
                listener.enterDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if isinstance( listener, HerocParserListener ):
                listener.exitDeclaration(self)




    def declaration(self):

        localctx = HerocParserParser.DeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_declaration)
        try:
            self.state = 34
            token = self._input.LA(1)
            if token in [self.LONG]:
                self.enterOuterAlt(localctx, 1)
                self.state = 32 
                self.declarationVariable()

            elif token in [self.IDENTIFIER]:
                self.enterOuterAlt(localctx, 2)
                self.state = 33 
                self.declarationFunction()

            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DeclarationVariableContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LONG(self):
            return self.getToken(HerocParserParser.LONG, 0)

        def IDENTIFIER(self):
            return self.getToken(HerocParserParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return HerocParserParser.RULE_declarationVariable

        def enterRule(self, listener:ParseTreeListener):
            if isinstance( listener, HerocParserListener ):
                listener.enterDeclarationVariable(self)

        def exitRule(self, listener:ParseTreeListener):
            if isinstance( listener, HerocParserListener ):
                listener.exitDeclarationVariable(self)




    def declarationVariable(self):

        localctx = HerocParserParser.DeclarationVariableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_declarationVariable)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 36
            self.match(self.LONG)
            self.state = 37
            self.match(self.IDENTIFIER)
            self.state = 38
            self.match(self.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DeclarationFunctionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def functionDeclarationArgsList(self):
            return self.getTypedRuleContext(HerocParserParser.FunctionDeclarationArgsListContext,0)


        def IDENTIFIER(self):
            return self.getToken(HerocParserParser.IDENTIFIER, 0)

        def compoundStatement(self):
            return self.getTypedRuleContext(HerocParserParser.CompoundStatementContext,0)


        def getRuleIndex(self):
            return HerocParserParser.RULE_declarationFunction

        def enterRule(self, listener:ParseTreeListener):
            if isinstance( listener, HerocParserListener ):
                listener.enterDeclarationFunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if isinstance( listener, HerocParserListener ):
                listener.exitDeclarationFunction(self)




    def declarationFunction(self):

        localctx = HerocParserParser.DeclarationFunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_declarationFunction)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 40
            self.match(self.IDENTIFIER)
            self.state = 41
            self.match(self.T__0)
            self.state = 43
            _la = self._input.LA(1)
            if _la==HerocParserParser.IDENTIFIER:
                self.state = 42 
                self.functionDeclarationArgsList()


            self.state = 45
            self.match(self.RIGHT_PAREN)
            self.state = 46 
            self.compoundStatement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FunctionDeclarationArgsListContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def functionDeclarationArgsList(self):
            return self.getTypedRuleContext(HerocParserParser.FunctionDeclarationArgsListContext,0)


        def IDENTIFIER(self):
            return self.getToken(HerocParserParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return HerocParserParser.RULE_functionDeclarationArgsList

        def enterRule(self, listener:ParseTreeListener):
            if isinstance( listener, HerocParserListener ):
                listener.enterFunctionDeclarationArgsList(self)

        def exitRule(self, listener:ParseTreeListener):
            if isinstance( listener, HerocParserListener ):
                listener.exitFunctionDeclarationArgsList(self)




    def functionDeclarationArgsList(self):

        localctx = HerocParserParser.FunctionDeclarationArgsListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_functionDeclarationArgsList)
        try:
            self.state = 52
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 48
                self.match(self.IDENTIFIER)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 49
                self.match(self.IDENTIFIER)
                self.state = 50
                self.match(self.COMMA)
                self.state = 51 
                self.functionDeclarationArgsList()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FunctionCallContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expressionList(self):
            return self.getTypedRuleContext(HerocParserParser.ExpressionListContext,0)


        def IDENTIFIER(self):
            return self.getToken(HerocParserParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return HerocParserParser.RULE_functionCall

        def enterRule(self, listener:ParseTreeListener):
            if isinstance( listener, HerocParserListener ):
                listener.enterFunctionCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if isinstance( listener, HerocParserListener ):
                listener.exitFunctionCall(self)




    def functionCall(self):

        localctx = HerocParserParser.FunctionCallContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_functionCall)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 54
            self.match(self.IDENTIFIER)
            self.state = 55
            self.match(self.T__0)
            self.state = 57
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << self.IDENTIFIER) | (1 << self.CONSTANT) | (1 << self.OCTAL_CONSTANT) | (1 << self.HEX_CONSTANT) | (1 << self.CHAR) | (1 << self.STRING))) != 0):
                self.state = 56 
                self.expressionList()


            self.state = 59
            self.match(self.RIGHT_PAREN)
            self.state = 60
            self.match(self.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CompoundStatementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def blockItemList(self):
            return self.getTypedRuleContext(HerocParserParser.BlockItemListContext,0)


        def getRuleIndex(self):
            return HerocParserParser.RULE_compoundStatement

        def enterRule(self, listener:ParseTreeListener):
            if isinstance( listener, HerocParserListener ):
                listener.enterCompoundStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if isinstance( listener, HerocParserListener ):
                listener.exitCompoundStatement(self)




    def compoundStatement(self):

        localctx = HerocParserParser.CompoundStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_compoundStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 62
            self.match(self.LEFT_BRACE)
            self.state = 64
            _la = self._input.LA(1)
            if _la==HerocParserParser.LONG or _la==HerocParserParser.IDENTIFIER:
                self.state = 63 
                self.blockItemList(0)


            self.state = 66
            self.match(self.RIGHT_BRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BlockItemListContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def blockItem(self):
            return self.getTypedRuleContext(HerocParserParser.BlockItemContext,0)


        def blockItemList(self):
            return self.getTypedRuleContext(HerocParserParser.BlockItemListContext,0)


        def getRuleIndex(self):
            return HerocParserParser.RULE_blockItemList

        def enterRule(self, listener:ParseTreeListener):
            if isinstance( listener, HerocParserListener ):
                listener.enterBlockItemList(self)

        def exitRule(self, listener:ParseTreeListener):
            if isinstance( listener, HerocParserListener ):
                listener.exitBlockItemList(self)



    def blockItemList(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = HerocParserParser.BlockItemListContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 14
        self.enterRecursionRule(localctx, 14, self.RULE_blockItemList, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 69 
            self.blockItem()
            self._ctx.stop = self._input.LT(-1)
            self.state = 75
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,6,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = HerocParserParser.BlockItemListContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_blockItemList)
                    self.state = 71
                    if not self.precpred(self._ctx, 1):
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 72 
                    self.blockItem() 
                self.state = 77
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,6,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class BlockItemContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def functionCall(self):
            return self.getTypedRuleContext(HerocParserParser.FunctionCallContext,0)


        def declarationVariable(self):
            return self.getTypedRuleContext(HerocParserParser.DeclarationVariableContext,0)


        def getRuleIndex(self):
            return HerocParserParser.RULE_blockItem

        def enterRule(self, listener:ParseTreeListener):
            if isinstance( listener, HerocParserListener ):
                listener.enterBlockItem(self)

        def exitRule(self, listener:ParseTreeListener):
            if isinstance( listener, HerocParserListener ):
                listener.exitBlockItem(self)




    def blockItem(self):

        localctx = HerocParserParser.BlockItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_blockItem)
        try:
            self.state = 80
            token = self._input.LA(1)
            if token in [self.LONG]:
                self.enterOuterAlt(localctx, 1)
                self.state = 78 
                self.declarationVariable()

            elif token in [self.IDENTIFIER]:
                self.enterOuterAlt(localctx, 2)
                self.state = 79 
                self.functionCall()

            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BinaryMathOperationsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PLUS(self):
            return self.getToken(HerocParserParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(HerocParserParser.MINUS, 0)

        def STAR(self):
            return self.getToken(HerocParserParser.STAR, 0)

        def DIV(self):
            return self.getToken(HerocParserParser.DIV, 0)

        def getRuleIndex(self):
            return HerocParserParser.RULE_binaryMathOperations

        def enterRule(self, listener:ParseTreeListener):
            if isinstance( listener, HerocParserListener ):
                listener.enterBinaryMathOperations(self)

        def exitRule(self, listener:ParseTreeListener):
            if isinstance( listener, HerocParserListener ):
                listener.exitBinaryMathOperations(self)




    def binaryMathOperations(self):

        localctx = HerocParserParser.BinaryMathOperationsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_binaryMathOperations)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 82
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << self.STAR) | (1 << self.PLUS) | (1 << self.MINUS) | (1 << self.DIV))) != 0)):
                self._errHandler.recoverInline(self)
            self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UnaryMathOperationsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PLUS_PLUS(self):
            return self.getToken(HerocParserParser.PLUS_PLUS, 0)

        def MINUS_MINUS(self):
            return self.getToken(HerocParserParser.MINUS_MINUS, 0)

        def getRuleIndex(self):
            return HerocParserParser.RULE_unaryMathOperations

        def enterRule(self, listener:ParseTreeListener):
            if isinstance( listener, HerocParserListener ):
                listener.enterUnaryMathOperations(self)

        def exitRule(self, listener:ParseTreeListener):
            if isinstance( listener, HerocParserListener ):
                listener.exitUnaryMathOperations(self)




    def unaryMathOperations(self):

        localctx = HerocParserParser.UnaryMathOperationsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_unaryMathOperations)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 84
            _la = self._input.LA(1)
            if not(_la==HerocParserParser.PLUS_PLUS or _la==HerocParserParser.MINUS_MINUS):
                self._errHandler.recoverInline(self)
            self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HEX_CONSTANT(self):
            return self.getToken(HerocParserParser.HEX_CONSTANT, 0)

        def binaryMathOperations(self):
            return self.getTypedRuleContext(HerocParserParser.BinaryMathOperationsContext,0)


        def OCTAL_CONSTANT(self):
            return self.getToken(HerocParserParser.OCTAL_CONSTANT, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(HerocParserParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(HerocParserParser.ExpressionContext,i)


        def STRING(self):
            return self.getToken(HerocParserParser.STRING, 0)

        def unaryMathOperations(self):
            return self.getTypedRuleContext(HerocParserParser.UnaryMathOperationsContext,0)


        def CONSTANT(self):
            return self.getToken(HerocParserParser.CONSTANT, 0)

        def CHAR(self):
            return self.getToken(HerocParserParser.CHAR, 0)

        def IDENTIFIER(self):
            return self.getToken(HerocParserParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return HerocParserParser.RULE_expression

        def enterRule(self, listener:ParseTreeListener):
            if isinstance( listener, HerocParserListener ):
                listener.enterExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if isinstance( listener, HerocParserListener ):
                listener.exitExpression(self)



    def expression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = HerocParserParser.ExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 22
        self.enterRecursionRule(localctx, 22, self.RULE_expression, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 93
            token = self._input.LA(1)
            if token in [self.IDENTIFIER]:
                self.state = 87
                self.match(self.IDENTIFIER)

            elif token in [self.CONSTANT]:
                self.state = 88
                self.match(self.CONSTANT)

            elif token in [self.OCTAL_CONSTANT]:
                self.state = 89
                self.match(self.OCTAL_CONSTANT)

            elif token in [self.HEX_CONSTANT]:
                self.state = 90
                self.match(self.HEX_CONSTANT)

            elif token in [self.CHAR]:
                self.state = 91
                self.match(self.CHAR)

            elif token in [self.STRING]:
                self.state = 92
                self.match(self.STRING)

            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 103
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,10,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 101
                    la_ = self._interp.adaptivePredict(self._input,9,self._ctx)
                    if la_ == 1:
                        localctx = HerocParserParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 95
                        if not self.precpred(self._ctx, 1):
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 96 
                        self.binaryMathOperations()
                        self.state = 97 
                        self.expression(2)
                        pass

                    elif la_ == 2:
                        localctx = HerocParserParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 99
                        if not self.precpred(self._ctx, 2):
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 100 
                        self.unaryMathOperations()
                        pass

             
                self.state = 105
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,10,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class ExpressionListContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expressionList(self):
            return self.getTypedRuleContext(HerocParserParser.ExpressionListContext,0)


        def expression(self):
            return self.getTypedRuleContext(HerocParserParser.ExpressionContext,0)


        def getRuleIndex(self):
            return HerocParserParser.RULE_expressionList

        def enterRule(self, listener:ParseTreeListener):
            if isinstance( listener, HerocParserListener ):
                listener.enterExpressionList(self)

        def exitRule(self, listener:ParseTreeListener):
            if isinstance( listener, HerocParserListener ):
                listener.exitExpressionList(self)




    def expressionList(self):

        localctx = HerocParserParser.ExpressionListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_expressionList)
        try:
            self.state = 111
            la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 106 
                self.expression(0)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 107 
                self.expression(0)
                self.state = 108
                self.match(self.COMMA)
                self.state = 109 
                self.expressionList()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[7] = self.blockItemList_sempred
        self._predicates[11] = self.expression_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def expression_sempred(self, localctx:ExpressionContext, predIndex:int):
            if predIndex == 1:
                return self.precpred(self._ctx, 1)
         

            if predIndex == 2:
                return self.precpred(self._ctx, 2)
         

    def blockItemList_sempred(self, localctx:BlockItemListContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 1)
         



